# coding: utf-8

"""
    Gitea API.

    This documentation describes the Gitea API.  # noqa: E501

    The version of the OpenAPI document: 1.18.3
    Generated by: https://openapi-generator.tech
"""


from __future__ import absolute_import

import re  # noqa: F401

from pydantic import validate_arguments, ValidationError
from typing_extensions import Annotated
from typing import overload, Optional, Union, Awaitable

from pydantic import Field, StrictInt, StrictStr

from typing import List, Optional

from swagger_client.models.create_key_option import CreateKeyOption
from swagger_client.models.create_org_option import CreateOrgOption
from swagger_client.models.create_repo_option import CreateRepoOption
from swagger_client.models.create_user_option import CreateUserOption
from swagger_client.models.cron import Cron
from swagger_client.models.edit_user_option import EditUserOption
from swagger_client.models.organization import Organization
from swagger_client.models.public_key import PublicKey
from swagger_client.models.repository import Repository
from swagger_client.models.user import User

from swagger_client.api_client import ApiClient
from swagger_client.exceptions import ApiTypeError, ApiValueError  # noqa: F401


class AdminApi(object):
    """NOTE: This class is auto generated by OpenAPI Generator
    Ref: https://openapi-generator.tech

    Do not edit the class manually.
    """

    def __init__(self, api_client=None):
        if api_client is None:
            api_client = ApiClient.get_default()
        self.api_client = api_client

    @overload
    async def admin_adopt_repository(
        self,
        owner: Annotated[StrictStr, Field(..., description="owner of the repo")],
        repo: Annotated[StrictStr, Field(..., description="name of the repo")],
        **kwargs
    ) -> None:  # noqa: E501
        ...

    @overload
    def admin_adopt_repository(
        self,
        owner: Annotated[StrictStr, Field(..., description="owner of the repo")],
        repo: Annotated[StrictStr, Field(..., description="name of the repo")],
        async_req: Optional[bool] = True,
        **kwargs
    ) -> None:  # noqa: E501
        ...

    @validate_arguments
    def admin_adopt_repository(
        self,
        owner: Annotated[StrictStr, Field(..., description="owner of the repo")],
        repo: Annotated[StrictStr, Field(..., description="name of the repo")],
        async_req: Optional[bool] = None,
        **kwargs
    ) -> Union[None, Awaitable[None]]:  # noqa: E501
        """Adopt unadopted files as a repository  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.admin_adopt_repository(owner, repo, async_req=True)
        >>> result = thread.get()

        :param owner: owner of the repo (required)
        :type owner: str
        :param repo: name of the repo (required)
        :type repo: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """
        kwargs["_return_http_data_only"] = True
        if async_req is not None:
            kwargs["async_req"] = async_req
        return self.admin_adopt_repository_with_http_info(
            owner, repo, **kwargs
        )  # noqa: E501

    @validate_arguments
    def admin_adopt_repository_with_http_info(
        self,
        owner: Annotated[StrictStr, Field(..., description="owner of the repo")],
        repo: Annotated[StrictStr, Field(..., description="name of the repo")],
        **kwargs
    ):  # noqa: E501
        """Adopt unadopted files as a repository  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.admin_adopt_repository_with_http_info(owner, repo, async_req=True)
        >>> result = thread.get()

        :param owner: owner of the repo (required)
        :type owner: str
        :param repo: name of the repo (required)
        :type repo: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """

        _params = locals()

        _all_params = ["owner", "repo"]
        _all_params.extend(
            [
                "async_req",
                "_return_http_data_only",
                "_preload_content",
                "_request_timeout",
                "_request_auth",
                "_content_type",
                "_headers",
            ]
        )

        # validate the arguments
        for _key, _val in _params["kwargs"].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method admin_adopt_repository" % _key
                )
            _params[_key] = _val
        del _params["kwargs"]

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params["owner"]:
            _path_params["owner"] = _params["owner"]

        if _params["repo"]:
            _path_params["repo"] = _params["repo"]

        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get("_headers", {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # authentication setting
        _auth_settings = [
            "TOTPHeader",
            "AuthorizationHeaderToken",
            "SudoHeader",
            "BasicAuth",
            "AccessToken",
            "SudoParam",
            "Token",
        ]  # noqa: E501

        _response_types_map = {}

        return self.api_client.call_api(
            "/admin/unadopted/{owner}/{repo}",
            "POST",
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get("async_req"),
            _return_http_data_only=_params.get("_return_http_data_only"),  # noqa: E501
            _preload_content=_params.get("_preload_content", True),
            _request_timeout=_params.get("_request_timeout"),
            collection_formats=_collection_formats,
            _request_auth=_params.get("_request_auth"),
        )

    @overload
    async def admin_create_org(
        self,
        username: Annotated[
            StrictStr,
            Field(
                ...,
                description="username of the user that will own the created organization",
            ),
        ],
        organization: CreateOrgOption,
        **kwargs
    ) -> Organization:  # noqa: E501
        ...

    @overload
    def admin_create_org(
        self,
        username: Annotated[
            StrictStr,
            Field(
                ...,
                description="username of the user that will own the created organization",
            ),
        ],
        organization: CreateOrgOption,
        async_req: Optional[bool] = True,
        **kwargs
    ) -> Organization:  # noqa: E501
        ...

    @validate_arguments
    def admin_create_org(
        self,
        username: Annotated[
            StrictStr,
            Field(
                ...,
                description="username of the user that will own the created organization",
            ),
        ],
        organization: CreateOrgOption,
        async_req: Optional[bool] = None,
        **kwargs
    ) -> Union[Organization, Awaitable[Organization]]:  # noqa: E501
        """Create an organization  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.admin_create_org(username, organization, async_req=True)
        >>> result = thread.get()

        :param username: username of the user that will own the created organization (required)
        :type username: str
        :param organization: (required)
        :type organization: CreateOrgOption
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: Organization
        """
        kwargs["_return_http_data_only"] = True
        if async_req is not None:
            kwargs["async_req"] = async_req
        return self.admin_create_org_with_http_info(
            username, organization, **kwargs
        )  # noqa: E501

    @validate_arguments
    def admin_create_org_with_http_info(
        self,
        username: Annotated[
            StrictStr,
            Field(
                ...,
                description="username of the user that will own the created organization",
            ),
        ],
        organization: CreateOrgOption,
        **kwargs
    ):  # noqa: E501
        """Create an organization  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.admin_create_org_with_http_info(username, organization, async_req=True)
        >>> result = thread.get()

        :param username: username of the user that will own the created organization (required)
        :type username: str
        :param organization: (required)
        :type organization: CreateOrgOption
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(Organization, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = ["username", "organization"]
        _all_params.extend(
            [
                "async_req",
                "_return_http_data_only",
                "_preload_content",
                "_request_timeout",
                "_request_auth",
                "_content_type",
                "_headers",
            ]
        )

        # validate the arguments
        for _key, _val in _params["kwargs"].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method admin_create_org" % _key
                )
            _params[_key] = _val
        del _params["kwargs"]

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params["username"]:
            _path_params["username"] = _params["username"]

        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get("_headers", {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params["organization"]:
            _body_params = _params["organization"]

        # set the HTTP header `Accept`
        _header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json"]
        )  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get(
            "_content_type",
            self.api_client.select_header_content_type(["application/json"]),
        )
        if _content_types_list:
            _header_params["Content-Type"] = _content_types_list

        # authentication setting
        _auth_settings = [
            "TOTPHeader",
            "AuthorizationHeaderToken",
            "SudoHeader",
            "BasicAuth",
            "AccessToken",
            "SudoParam",
            "Token",
        ]  # noqa: E501

        _response_types_map = {
            "201": "Organization",
            "403": None,
            "422": None,
        }

        return self.api_client.call_api(
            "/admin/users/{username}/orgs",
            "POST",
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get("async_req"),
            _return_http_data_only=_params.get("_return_http_data_only"),  # noqa: E501
            _preload_content=_params.get("_preload_content", True),
            _request_timeout=_params.get("_request_timeout"),
            collection_formats=_collection_formats,
            _request_auth=_params.get("_request_auth"),
        )

    @overload
    async def admin_create_public_key(
        self,
        username: Annotated[StrictStr, Field(..., description="username of the user")],
        key: Optional[CreateKeyOption] = None,
        **kwargs
    ) -> PublicKey:  # noqa: E501
        ...

    @overload
    def admin_create_public_key(
        self,
        username: Annotated[StrictStr, Field(..., description="username of the user")],
        key: Optional[CreateKeyOption] = None,
        async_req: Optional[bool] = True,
        **kwargs
    ) -> PublicKey:  # noqa: E501
        ...

    @validate_arguments
    def admin_create_public_key(
        self,
        username: Annotated[StrictStr, Field(..., description="username of the user")],
        key: Optional[CreateKeyOption] = None,
        async_req: Optional[bool] = None,
        **kwargs
    ) -> Union[PublicKey, Awaitable[PublicKey]]:  # noqa: E501
        """Add a public key on behalf of a user  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.admin_create_public_key(username, key, async_req=True)
        >>> result = thread.get()

        :param username: username of the user (required)
        :type username: str
        :param key:
        :type key: CreateKeyOption
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: PublicKey
        """
        kwargs["_return_http_data_only"] = True
        if async_req is not None:
            kwargs["async_req"] = async_req
        return self.admin_create_public_key_with_http_info(
            username, key, **kwargs
        )  # noqa: E501

    @validate_arguments
    def admin_create_public_key_with_http_info(
        self,
        username: Annotated[StrictStr, Field(..., description="username of the user")],
        key: Optional[CreateKeyOption] = None,
        **kwargs
    ):  # noqa: E501
        """Add a public key on behalf of a user  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.admin_create_public_key_with_http_info(username, key, async_req=True)
        >>> result = thread.get()

        :param username: username of the user (required)
        :type username: str
        :param key:
        :type key: CreateKeyOption
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(PublicKey, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = ["username", "key"]
        _all_params.extend(
            [
                "async_req",
                "_return_http_data_only",
                "_preload_content",
                "_request_timeout",
                "_request_auth",
                "_content_type",
                "_headers",
            ]
        )

        # validate the arguments
        for _key, _val in _params["kwargs"].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method admin_create_public_key" % _key
                )
            _params[_key] = _val
        del _params["kwargs"]

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params["username"]:
            _path_params["username"] = _params["username"]

        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get("_headers", {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params["key"]:
            _body_params = _params["key"]

        # set the HTTP header `Accept`
        _header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json"]
        )  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get(
            "_content_type",
            self.api_client.select_header_content_type(["application/json"]),
        )
        if _content_types_list:
            _header_params["Content-Type"] = _content_types_list

        # authentication setting
        _auth_settings = [
            "TOTPHeader",
            "AuthorizationHeaderToken",
            "SudoHeader",
            "BasicAuth",
            "AccessToken",
            "SudoParam",
            "Token",
        ]  # noqa: E501

        _response_types_map = {
            "201": "PublicKey",
            "403": None,
            "422": None,
        }

        return self.api_client.call_api(
            "/admin/users/{username}/keys",
            "POST",
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get("async_req"),
            _return_http_data_only=_params.get("_return_http_data_only"),  # noqa: E501
            _preload_content=_params.get("_preload_content", True),
            _request_timeout=_params.get("_request_timeout"),
            collection_formats=_collection_formats,
            _request_auth=_params.get("_request_auth"),
        )

    @overload
    async def admin_create_repo(
        self,
        username: Annotated[
            StrictStr,
            Field(
                ...,
                description="username of the user. This user will own the created repository",
            ),
        ],
        repository: CreateRepoOption,
        **kwargs
    ) -> Repository:  # noqa: E501
        ...

    @overload
    def admin_create_repo(
        self,
        username: Annotated[
            StrictStr,
            Field(
                ...,
                description="username of the user. This user will own the created repository",
            ),
        ],
        repository: CreateRepoOption,
        async_req: Optional[bool] = True,
        **kwargs
    ) -> Repository:  # noqa: E501
        ...

    @validate_arguments
    def admin_create_repo(
        self,
        username: Annotated[
            StrictStr,
            Field(
                ...,
                description="username of the user. This user will own the created repository",
            ),
        ],
        repository: CreateRepoOption,
        async_req: Optional[bool] = None,
        **kwargs
    ) -> Union[Repository, Awaitable[Repository]]:  # noqa: E501
        """Create a repository on behalf of a user  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.admin_create_repo(username, repository, async_req=True)
        >>> result = thread.get()

        :param username: username of the user. This user will own the created repository (required)
        :type username: str
        :param repository: (required)
        :type repository: CreateRepoOption
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: Repository
        """
        kwargs["_return_http_data_only"] = True
        if async_req is not None:
            kwargs["async_req"] = async_req
        return self.admin_create_repo_with_http_info(
            username, repository, **kwargs
        )  # noqa: E501

    @validate_arguments
    def admin_create_repo_with_http_info(
        self,
        username: Annotated[
            StrictStr,
            Field(
                ...,
                description="username of the user. This user will own the created repository",
            ),
        ],
        repository: CreateRepoOption,
        **kwargs
    ):  # noqa: E501
        """Create a repository on behalf of a user  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.admin_create_repo_with_http_info(username, repository, async_req=True)
        >>> result = thread.get()

        :param username: username of the user. This user will own the created repository (required)
        :type username: str
        :param repository: (required)
        :type repository: CreateRepoOption
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(Repository, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = ["username", "repository"]
        _all_params.extend(
            [
                "async_req",
                "_return_http_data_only",
                "_preload_content",
                "_request_timeout",
                "_request_auth",
                "_content_type",
                "_headers",
            ]
        )

        # validate the arguments
        for _key, _val in _params["kwargs"].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method admin_create_repo" % _key
                )
            _params[_key] = _val
        del _params["kwargs"]

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params["username"]:
            _path_params["username"] = _params["username"]

        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get("_headers", {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params["repository"]:
            _body_params = _params["repository"]

        # set the HTTP header `Accept`
        _header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json"]
        )  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get(
            "_content_type",
            self.api_client.select_header_content_type(["application/json"]),
        )
        if _content_types_list:
            _header_params["Content-Type"] = _content_types_list

        # authentication setting
        _auth_settings = [
            "TOTPHeader",
            "AuthorizationHeaderToken",
            "SudoHeader",
            "BasicAuth",
            "AccessToken",
            "SudoParam",
            "Token",
        ]  # noqa: E501

        _response_types_map = {
            "201": "Repository",
            "403": None,
            "404": None,
            "409": None,
            "422": None,
        }

        return self.api_client.call_api(
            "/admin/users/{username}/repos",
            "POST",
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get("async_req"),
            _return_http_data_only=_params.get("_return_http_data_only"),  # noqa: E501
            _preload_content=_params.get("_preload_content", True),
            _request_timeout=_params.get("_request_timeout"),
            collection_formats=_collection_formats,
            _request_auth=_params.get("_request_auth"),
        )

    @overload
    async def admin_create_user(
        self, body: Optional[CreateUserOption] = None, **kwargs
    ) -> User:  # noqa: E501
        ...

    @overload
    def admin_create_user(
        self,
        body: Optional[CreateUserOption] = None,
        async_req: Optional[bool] = True,
        **kwargs
    ) -> User:  # noqa: E501
        ...

    @validate_arguments
    def admin_create_user(
        self,
        body: Optional[CreateUserOption] = None,
        async_req: Optional[bool] = None,
        **kwargs
    ) -> Union[User, Awaitable[User]]:  # noqa: E501
        """Create a user  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.admin_create_user(body, async_req=True)
        >>> result = thread.get()

        :param body:
        :type body: CreateUserOption
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: User
        """
        kwargs["_return_http_data_only"] = True
        if async_req is not None:
            kwargs["async_req"] = async_req
        return self.admin_create_user_with_http_info(body, **kwargs)  # noqa: E501

    @validate_arguments
    def admin_create_user_with_http_info(
        self, body: Optional[CreateUserOption] = None, **kwargs
    ):  # noqa: E501
        """Create a user  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.admin_create_user_with_http_info(body, async_req=True)
        >>> result = thread.get()

        :param body:
        :type body: CreateUserOption
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(User, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = ["body"]
        _all_params.extend(
            [
                "async_req",
                "_return_http_data_only",
                "_preload_content",
                "_request_timeout",
                "_request_auth",
                "_content_type",
                "_headers",
            ]
        )

        # validate the arguments
        for _key, _val in _params["kwargs"].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method admin_create_user" % _key
                )
            _params[_key] = _val
        del _params["kwargs"]

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get("_headers", {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params["body"]:
            _body_params = _params["body"]

        # set the HTTP header `Accept`
        _header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json"]
        )  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get(
            "_content_type",
            self.api_client.select_header_content_type(["application/json"]),
        )
        if _content_types_list:
            _header_params["Content-Type"] = _content_types_list

        # authentication setting
        _auth_settings = [
            "TOTPHeader",
            "AuthorizationHeaderToken",
            "SudoHeader",
            "BasicAuth",
            "AccessToken",
            "SudoParam",
            "Token",
        ]  # noqa: E501

        _response_types_map = {
            "201": "User",
            "400": None,
            "403": None,
            "422": None,
        }

        return self.api_client.call_api(
            "/admin/users",
            "POST",
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get("async_req"),
            _return_http_data_only=_params.get("_return_http_data_only"),  # noqa: E501
            _preload_content=_params.get("_preload_content", True),
            _request_timeout=_params.get("_request_timeout"),
            collection_formats=_collection_formats,
            _request_auth=_params.get("_request_auth"),
        )

    @overload
    async def admin_cron_list(
        self,
        page: Annotated[
            Optional[StrictInt],
            Field(description="page number of results to return (1-based)"),
        ] = None,
        limit: Annotated[
            Optional[StrictInt], Field(description="page size of results")
        ] = None,
        **kwargs
    ) -> List[Cron]:  # noqa: E501
        ...

    @overload
    def admin_cron_list(
        self,
        page: Annotated[
            Optional[StrictInt],
            Field(description="page number of results to return (1-based)"),
        ] = None,
        limit: Annotated[
            Optional[StrictInt], Field(description="page size of results")
        ] = None,
        async_req: Optional[bool] = True,
        **kwargs
    ) -> List[Cron]:  # noqa: E501
        ...

    @validate_arguments
    def admin_cron_list(
        self,
        page: Annotated[
            Optional[StrictInt],
            Field(description="page number of results to return (1-based)"),
        ] = None,
        limit: Annotated[
            Optional[StrictInt], Field(description="page size of results")
        ] = None,
        async_req: Optional[bool] = None,
        **kwargs
    ) -> Union[List[Cron], Awaitable[List[Cron]]]:  # noqa: E501
        """List cron tasks  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.admin_cron_list(page, limit, async_req=True)
        >>> result = thread.get()

        :param page: page number of results to return (1-based)
        :type page: int
        :param limit: page size of results
        :type limit: int
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: List[Cron]
        """
        kwargs["_return_http_data_only"] = True
        if async_req is not None:
            kwargs["async_req"] = async_req
        return self.admin_cron_list_with_http_info(page, limit, **kwargs)  # noqa: E501

    @validate_arguments
    def admin_cron_list_with_http_info(
        self,
        page: Annotated[
            Optional[StrictInt],
            Field(description="page number of results to return (1-based)"),
        ] = None,
        limit: Annotated[
            Optional[StrictInt], Field(description="page size of results")
        ] = None,
        **kwargs
    ):  # noqa: E501
        """List cron tasks  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.admin_cron_list_with_http_info(page, limit, async_req=True)
        >>> result = thread.get()

        :param page: page number of results to return (1-based)
        :type page: int
        :param limit: page size of results
        :type limit: int
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(List[Cron], status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = ["page", "limit"]
        _all_params.extend(
            [
                "async_req",
                "_return_http_data_only",
                "_preload_content",
                "_request_timeout",
                "_request_auth",
                "_content_type",
                "_headers",
            ]
        )

        # validate the arguments
        for _key, _val in _params["kwargs"].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method admin_cron_list" % _key
                )
            _params[_key] = _val
        del _params["kwargs"]

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        if _params.get("page") is not None:  # noqa: E501
            _query_params.append(("page", _params["page"]))

        if _params.get("limit") is not None:  # noqa: E501
            _query_params.append(("limit", _params["limit"]))

        # process the header parameters
        _header_params = dict(_params.get("_headers", {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json"]
        )  # noqa: E501

        # authentication setting
        _auth_settings = [
            "TOTPHeader",
            "AuthorizationHeaderToken",
            "SudoHeader",
            "BasicAuth",
            "AccessToken",
            "SudoParam",
            "Token",
        ]  # noqa: E501

        _response_types_map = {
            "200": "List[Cron]",
            "403": None,
        }

        return self.api_client.call_api(
            "/admin/cron",
            "GET",
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get("async_req"),
            _return_http_data_only=_params.get("_return_http_data_only"),  # noqa: E501
            _preload_content=_params.get("_preload_content", True),
            _request_timeout=_params.get("_request_timeout"),
            collection_formats=_collection_formats,
            _request_auth=_params.get("_request_auth"),
        )

    @overload
    async def admin_cron_run(
        self,
        task: Annotated[StrictStr, Field(..., description="task to run")],
        **kwargs
    ) -> None:  # noqa: E501
        ...

    @overload
    def admin_cron_run(
        self,
        task: Annotated[StrictStr, Field(..., description="task to run")],
        async_req: Optional[bool] = True,
        **kwargs
    ) -> None:  # noqa: E501
        ...

    @validate_arguments
    def admin_cron_run(
        self,
        task: Annotated[StrictStr, Field(..., description="task to run")],
        async_req: Optional[bool] = None,
        **kwargs
    ) -> Union[None, Awaitable[None]]:  # noqa: E501
        """Run cron task  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.admin_cron_run(task, async_req=True)
        >>> result = thread.get()

        :param task: task to run (required)
        :type task: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """
        kwargs["_return_http_data_only"] = True
        if async_req is not None:
            kwargs["async_req"] = async_req
        return self.admin_cron_run_with_http_info(task, **kwargs)  # noqa: E501

    @validate_arguments
    def admin_cron_run_with_http_info(
        self,
        task: Annotated[StrictStr, Field(..., description="task to run")],
        **kwargs
    ):  # noqa: E501
        """Run cron task  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.admin_cron_run_with_http_info(task, async_req=True)
        >>> result = thread.get()

        :param task: task to run (required)
        :type task: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """

        _params = locals()

        _all_params = ["task"]
        _all_params.extend(
            [
                "async_req",
                "_return_http_data_only",
                "_preload_content",
                "_request_timeout",
                "_request_auth",
                "_content_type",
                "_headers",
            ]
        )

        # validate the arguments
        for _key, _val in _params["kwargs"].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method admin_cron_run" % _key
                )
            _params[_key] = _val
        del _params["kwargs"]

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params["task"]:
            _path_params["task"] = _params["task"]

        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get("_headers", {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # authentication setting
        _auth_settings = [
            "TOTPHeader",
            "AuthorizationHeaderToken",
            "SudoHeader",
            "BasicAuth",
            "AccessToken",
            "SudoParam",
            "Token",
        ]  # noqa: E501

        _response_types_map = {}

        return self.api_client.call_api(
            "/admin/cron/{task}",
            "POST",
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get("async_req"),
            _return_http_data_only=_params.get("_return_http_data_only"),  # noqa: E501
            _preload_content=_params.get("_preload_content", True),
            _request_timeout=_params.get("_request_timeout"),
            collection_formats=_collection_formats,
            _request_auth=_params.get("_request_auth"),
        )

    @overload
    async def admin_delete_unadopted_repository(
        self,
        owner: Annotated[StrictStr, Field(..., description="owner of the repo")],
        repo: Annotated[StrictStr, Field(..., description="name of the repo")],
        **kwargs
    ) -> None:  # noqa: E501
        ...

    @overload
    def admin_delete_unadopted_repository(
        self,
        owner: Annotated[StrictStr, Field(..., description="owner of the repo")],
        repo: Annotated[StrictStr, Field(..., description="name of the repo")],
        async_req: Optional[bool] = True,
        **kwargs
    ) -> None:  # noqa: E501
        ...

    @validate_arguments
    def admin_delete_unadopted_repository(
        self,
        owner: Annotated[StrictStr, Field(..., description="owner of the repo")],
        repo: Annotated[StrictStr, Field(..., description="name of the repo")],
        async_req: Optional[bool] = None,
        **kwargs
    ) -> Union[None, Awaitable[None]]:  # noqa: E501
        """Delete unadopted files  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.admin_delete_unadopted_repository(owner, repo, async_req=True)
        >>> result = thread.get()

        :param owner: owner of the repo (required)
        :type owner: str
        :param repo: name of the repo (required)
        :type repo: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """
        kwargs["_return_http_data_only"] = True
        if async_req is not None:
            kwargs["async_req"] = async_req
        return self.admin_delete_unadopted_repository_with_http_info(
            owner, repo, **kwargs
        )  # noqa: E501

    @validate_arguments
    def admin_delete_unadopted_repository_with_http_info(
        self,
        owner: Annotated[StrictStr, Field(..., description="owner of the repo")],
        repo: Annotated[StrictStr, Field(..., description="name of the repo")],
        **kwargs
    ):  # noqa: E501
        """Delete unadopted files  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.admin_delete_unadopted_repository_with_http_info(owner, repo, async_req=True)
        >>> result = thread.get()

        :param owner: owner of the repo (required)
        :type owner: str
        :param repo: name of the repo (required)
        :type repo: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """

        _params = locals()

        _all_params = ["owner", "repo"]
        _all_params.extend(
            [
                "async_req",
                "_return_http_data_only",
                "_preload_content",
                "_request_timeout",
                "_request_auth",
                "_content_type",
                "_headers",
            ]
        )

        # validate the arguments
        for _key, _val in _params["kwargs"].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method admin_delete_unadopted_repository" % _key
                )
            _params[_key] = _val
        del _params["kwargs"]

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params["owner"]:
            _path_params["owner"] = _params["owner"]

        if _params["repo"]:
            _path_params["repo"] = _params["repo"]

        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get("_headers", {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # authentication setting
        _auth_settings = [
            "TOTPHeader",
            "AuthorizationHeaderToken",
            "SudoHeader",
            "BasicAuth",
            "AccessToken",
            "SudoParam",
            "Token",
        ]  # noqa: E501

        _response_types_map = {}

        return self.api_client.call_api(
            "/admin/unadopted/{owner}/{repo}",
            "DELETE",
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get("async_req"),
            _return_http_data_only=_params.get("_return_http_data_only"),  # noqa: E501
            _preload_content=_params.get("_preload_content", True),
            _request_timeout=_params.get("_request_timeout"),
            collection_formats=_collection_formats,
            _request_auth=_params.get("_request_auth"),
        )

    @overload
    async def admin_delete_user(
        self,
        username: Annotated[
            StrictStr, Field(..., description="username of user to delete")
        ],
        **kwargs
    ) -> None:  # noqa: E501
        ...

    @overload
    def admin_delete_user(
        self,
        username: Annotated[
            StrictStr, Field(..., description="username of user to delete")
        ],
        async_req: Optional[bool] = True,
        **kwargs
    ) -> None:  # noqa: E501
        ...

    @validate_arguments
    def admin_delete_user(
        self,
        username: Annotated[
            StrictStr, Field(..., description="username of user to delete")
        ],
        async_req: Optional[bool] = None,
        **kwargs
    ) -> Union[None, Awaitable[None]]:  # noqa: E501
        """Delete a user  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.admin_delete_user(username, async_req=True)
        >>> result = thread.get()

        :param username: username of user to delete (required)
        :type username: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """
        kwargs["_return_http_data_only"] = True
        if async_req is not None:
            kwargs["async_req"] = async_req
        return self.admin_delete_user_with_http_info(username, **kwargs)  # noqa: E501

    @validate_arguments
    def admin_delete_user_with_http_info(
        self,
        username: Annotated[
            StrictStr, Field(..., description="username of user to delete")
        ],
        **kwargs
    ):  # noqa: E501
        """Delete a user  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.admin_delete_user_with_http_info(username, async_req=True)
        >>> result = thread.get()

        :param username: username of user to delete (required)
        :type username: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """

        _params = locals()

        _all_params = ["username"]
        _all_params.extend(
            [
                "async_req",
                "_return_http_data_only",
                "_preload_content",
                "_request_timeout",
                "_request_auth",
                "_content_type",
                "_headers",
            ]
        )

        # validate the arguments
        for _key, _val in _params["kwargs"].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method admin_delete_user" % _key
                )
            _params[_key] = _val
        del _params["kwargs"]

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params["username"]:
            _path_params["username"] = _params["username"]

        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get("_headers", {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # authentication setting
        _auth_settings = [
            "TOTPHeader",
            "AuthorizationHeaderToken",
            "SudoHeader",
            "BasicAuth",
            "AccessToken",
            "SudoParam",
            "Token",
        ]  # noqa: E501

        _response_types_map = {}

        return self.api_client.call_api(
            "/admin/users/{username}",
            "DELETE",
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get("async_req"),
            _return_http_data_only=_params.get("_return_http_data_only"),  # noqa: E501
            _preload_content=_params.get("_preload_content", True),
            _request_timeout=_params.get("_request_timeout"),
            collection_formats=_collection_formats,
            _request_auth=_params.get("_request_auth"),
        )

    @overload
    async def admin_delete_user_public_key(
        self,
        username: Annotated[StrictStr, Field(..., description="username of user")],
        id: Annotated[StrictInt, Field(..., description="id of the key to delete")],
        **kwargs
    ) -> None:  # noqa: E501
        ...

    @overload
    def admin_delete_user_public_key(
        self,
        username: Annotated[StrictStr, Field(..., description="username of user")],
        id: Annotated[StrictInt, Field(..., description="id of the key to delete")],
        async_req: Optional[bool] = True,
        **kwargs
    ) -> None:  # noqa: E501
        ...

    @validate_arguments
    def admin_delete_user_public_key(
        self,
        username: Annotated[StrictStr, Field(..., description="username of user")],
        id: Annotated[StrictInt, Field(..., description="id of the key to delete")],
        async_req: Optional[bool] = None,
        **kwargs
    ) -> Union[None, Awaitable[None]]:  # noqa: E501
        """Delete a user's public key  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.admin_delete_user_public_key(username, id, async_req=True)
        >>> result = thread.get()

        :param username: username of user (required)
        :type username: str
        :param id: id of the key to delete (required)
        :type id: int
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """
        kwargs["_return_http_data_only"] = True
        if async_req is not None:
            kwargs["async_req"] = async_req
        return self.admin_delete_user_public_key_with_http_info(
            username, id, **kwargs
        )  # noqa: E501

    @validate_arguments
    def admin_delete_user_public_key_with_http_info(
        self,
        username: Annotated[StrictStr, Field(..., description="username of user")],
        id: Annotated[StrictInt, Field(..., description="id of the key to delete")],
        **kwargs
    ):  # noqa: E501
        """Delete a user's public key  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.admin_delete_user_public_key_with_http_info(username, id, async_req=True)
        >>> result = thread.get()

        :param username: username of user (required)
        :type username: str
        :param id: id of the key to delete (required)
        :type id: int
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """

        _params = locals()

        _all_params = ["username", "id"]
        _all_params.extend(
            [
                "async_req",
                "_return_http_data_only",
                "_preload_content",
                "_request_timeout",
                "_request_auth",
                "_content_type",
                "_headers",
            ]
        )

        # validate the arguments
        for _key, _val in _params["kwargs"].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method admin_delete_user_public_key" % _key
                )
            _params[_key] = _val
        del _params["kwargs"]

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params["username"]:
            _path_params["username"] = _params["username"]

        if _params["id"]:
            _path_params["id"] = _params["id"]

        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get("_headers", {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # authentication setting
        _auth_settings = [
            "TOTPHeader",
            "AuthorizationHeaderToken",
            "SudoHeader",
            "BasicAuth",
            "AccessToken",
            "SudoParam",
            "Token",
        ]  # noqa: E501

        _response_types_map = {}

        return self.api_client.call_api(
            "/admin/users/{username}/keys/{id}",
            "DELETE",
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get("async_req"),
            _return_http_data_only=_params.get("_return_http_data_only"),  # noqa: E501
            _preload_content=_params.get("_preload_content", True),
            _request_timeout=_params.get("_request_timeout"),
            collection_formats=_collection_formats,
            _request_auth=_params.get("_request_auth"),
        )

    @overload
    async def admin_edit_user(
        self,
        username: Annotated[
            StrictStr, Field(..., description="username of user to edit")
        ],
        body: Optional[EditUserOption] = None,
        **kwargs
    ) -> User:  # noqa: E501
        ...

    @overload
    def admin_edit_user(
        self,
        username: Annotated[
            StrictStr, Field(..., description="username of user to edit")
        ],
        body: Optional[EditUserOption] = None,
        async_req: Optional[bool] = True,
        **kwargs
    ) -> User:  # noqa: E501
        ...

    @validate_arguments
    def admin_edit_user(
        self,
        username: Annotated[
            StrictStr, Field(..., description="username of user to edit")
        ],
        body: Optional[EditUserOption] = None,
        async_req: Optional[bool] = None,
        **kwargs
    ) -> Union[User, Awaitable[User]]:  # noqa: E501
        """Edit an existing user  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.admin_edit_user(username, body, async_req=True)
        >>> result = thread.get()

        :param username: username of user to edit (required)
        :type username: str
        :param body:
        :type body: EditUserOption
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: User
        """
        kwargs["_return_http_data_only"] = True
        if async_req is not None:
            kwargs["async_req"] = async_req
        return self.admin_edit_user_with_http_info(
            username, body, **kwargs
        )  # noqa: E501

    @validate_arguments
    def admin_edit_user_with_http_info(
        self,
        username: Annotated[
            StrictStr, Field(..., description="username of user to edit")
        ],
        body: Optional[EditUserOption] = None,
        **kwargs
    ):  # noqa: E501
        """Edit an existing user  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.admin_edit_user_with_http_info(username, body, async_req=True)
        >>> result = thread.get()

        :param username: username of user to edit (required)
        :type username: str
        :param body:
        :type body: EditUserOption
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(User, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = ["username", "body"]
        _all_params.extend(
            [
                "async_req",
                "_return_http_data_only",
                "_preload_content",
                "_request_timeout",
                "_request_auth",
                "_content_type",
                "_headers",
            ]
        )

        # validate the arguments
        for _key, _val in _params["kwargs"].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method admin_edit_user" % _key
                )
            _params[_key] = _val
        del _params["kwargs"]

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params["username"]:
            _path_params["username"] = _params["username"]

        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get("_headers", {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params["body"]:
            _body_params = _params["body"]

        # set the HTTP header `Accept`
        _header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json"]
        )  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get(
            "_content_type",
            self.api_client.select_header_content_type(["application/json"]),
        )
        if _content_types_list:
            _header_params["Content-Type"] = _content_types_list

        # authentication setting
        _auth_settings = [
            "TOTPHeader",
            "AuthorizationHeaderToken",
            "SudoHeader",
            "BasicAuth",
            "AccessToken",
            "SudoParam",
            "Token",
        ]  # noqa: E501

        _response_types_map = {
            "200": "User",
            "403": None,
            "422": None,
        }

        return self.api_client.call_api(
            "/admin/users/{username}",
            "PATCH",
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get("async_req"),
            _return_http_data_only=_params.get("_return_http_data_only"),  # noqa: E501
            _preload_content=_params.get("_preload_content", True),
            _request_timeout=_params.get("_request_timeout"),
            collection_formats=_collection_formats,
            _request_auth=_params.get("_request_auth"),
        )

    @overload
    async def admin_get_all_orgs(
        self,
        page: Annotated[
            Optional[StrictInt],
            Field(description="page number of results to return (1-based)"),
        ] = None,
        limit: Annotated[
            Optional[StrictInt], Field(description="page size of results")
        ] = None,
        **kwargs
    ) -> List[Organization]:  # noqa: E501
        ...

    @overload
    def admin_get_all_orgs(
        self,
        page: Annotated[
            Optional[StrictInt],
            Field(description="page number of results to return (1-based)"),
        ] = None,
        limit: Annotated[
            Optional[StrictInt], Field(description="page size of results")
        ] = None,
        async_req: Optional[bool] = True,
        **kwargs
    ) -> List[Organization]:  # noqa: E501
        ...

    @validate_arguments
    def admin_get_all_orgs(
        self,
        page: Annotated[
            Optional[StrictInt],
            Field(description="page number of results to return (1-based)"),
        ] = None,
        limit: Annotated[
            Optional[StrictInt], Field(description="page size of results")
        ] = None,
        async_req: Optional[bool] = None,
        **kwargs
    ) -> Union[List[Organization], Awaitable[List[Organization]]]:  # noqa: E501
        """List all organizations  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.admin_get_all_orgs(page, limit, async_req=True)
        >>> result = thread.get()

        :param page: page number of results to return (1-based)
        :type page: int
        :param limit: page size of results
        :type limit: int
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: List[Organization]
        """
        kwargs["_return_http_data_only"] = True
        if async_req is not None:
            kwargs["async_req"] = async_req
        return self.admin_get_all_orgs_with_http_info(
            page, limit, **kwargs
        )  # noqa: E501

    @validate_arguments
    def admin_get_all_orgs_with_http_info(
        self,
        page: Annotated[
            Optional[StrictInt],
            Field(description="page number of results to return (1-based)"),
        ] = None,
        limit: Annotated[
            Optional[StrictInt], Field(description="page size of results")
        ] = None,
        **kwargs
    ):  # noqa: E501
        """List all organizations  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.admin_get_all_orgs_with_http_info(page, limit, async_req=True)
        >>> result = thread.get()

        :param page: page number of results to return (1-based)
        :type page: int
        :param limit: page size of results
        :type limit: int
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(List[Organization], status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = ["page", "limit"]
        _all_params.extend(
            [
                "async_req",
                "_return_http_data_only",
                "_preload_content",
                "_request_timeout",
                "_request_auth",
                "_content_type",
                "_headers",
            ]
        )

        # validate the arguments
        for _key, _val in _params["kwargs"].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method admin_get_all_orgs" % _key
                )
            _params[_key] = _val
        del _params["kwargs"]

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        if _params.get("page") is not None:  # noqa: E501
            _query_params.append(("page", _params["page"]))

        if _params.get("limit") is not None:  # noqa: E501
            _query_params.append(("limit", _params["limit"]))

        # process the header parameters
        _header_params = dict(_params.get("_headers", {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json"]
        )  # noqa: E501

        # authentication setting
        _auth_settings = [
            "TOTPHeader",
            "AuthorizationHeaderToken",
            "SudoHeader",
            "BasicAuth",
            "AccessToken",
            "SudoParam",
            "Token",
        ]  # noqa: E501

        _response_types_map = {
            "200": "List[Organization]",
            "403": None,
        }

        return self.api_client.call_api(
            "/admin/orgs",
            "GET",
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get("async_req"),
            _return_http_data_only=_params.get("_return_http_data_only"),  # noqa: E501
            _preload_content=_params.get("_preload_content", True),
            _request_timeout=_params.get("_request_timeout"),
            collection_formats=_collection_formats,
            _request_auth=_params.get("_request_auth"),
        )

    @overload
    async def admin_get_all_users(
        self,
        page: Annotated[
            Optional[StrictInt],
            Field(description="page number of results to return (1-based)"),
        ] = None,
        limit: Annotated[
            Optional[StrictInt], Field(description="page size of results")
        ] = None,
        **kwargs
    ) -> List[User]:  # noqa: E501
        ...

    @overload
    def admin_get_all_users(
        self,
        page: Annotated[
            Optional[StrictInt],
            Field(description="page number of results to return (1-based)"),
        ] = None,
        limit: Annotated[
            Optional[StrictInt], Field(description="page size of results")
        ] = None,
        async_req: Optional[bool] = True,
        **kwargs
    ) -> List[User]:  # noqa: E501
        ...

    @validate_arguments
    def admin_get_all_users(
        self,
        page: Annotated[
            Optional[StrictInt],
            Field(description="page number of results to return (1-based)"),
        ] = None,
        limit: Annotated[
            Optional[StrictInt], Field(description="page size of results")
        ] = None,
        async_req: Optional[bool] = None,
        **kwargs
    ) -> Union[List[User], Awaitable[List[User]]]:  # noqa: E501
        """List all users  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.admin_get_all_users(page, limit, async_req=True)
        >>> result = thread.get()

        :param page: page number of results to return (1-based)
        :type page: int
        :param limit: page size of results
        :type limit: int
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: List[User]
        """
        kwargs["_return_http_data_only"] = True
        if async_req is not None:
            kwargs["async_req"] = async_req
        return self.admin_get_all_users_with_http_info(
            page, limit, **kwargs
        )  # noqa: E501

    @validate_arguments
    def admin_get_all_users_with_http_info(
        self,
        page: Annotated[
            Optional[StrictInt],
            Field(description="page number of results to return (1-based)"),
        ] = None,
        limit: Annotated[
            Optional[StrictInt], Field(description="page size of results")
        ] = None,
        **kwargs
    ):  # noqa: E501
        """List all users  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.admin_get_all_users_with_http_info(page, limit, async_req=True)
        >>> result = thread.get()

        :param page: page number of results to return (1-based)
        :type page: int
        :param limit: page size of results
        :type limit: int
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(List[User], status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = ["page", "limit"]
        _all_params.extend(
            [
                "async_req",
                "_return_http_data_only",
                "_preload_content",
                "_request_timeout",
                "_request_auth",
                "_content_type",
                "_headers",
            ]
        )

        # validate the arguments
        for _key, _val in _params["kwargs"].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method admin_get_all_users" % _key
                )
            _params[_key] = _val
        del _params["kwargs"]

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        if _params.get("page") is not None:  # noqa: E501
            _query_params.append(("page", _params["page"]))

        if _params.get("limit") is not None:  # noqa: E501
            _query_params.append(("limit", _params["limit"]))

        # process the header parameters
        _header_params = dict(_params.get("_headers", {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json"]
        )  # noqa: E501

        # authentication setting
        _auth_settings = [
            "TOTPHeader",
            "AuthorizationHeaderToken",
            "SudoHeader",
            "BasicAuth",
            "AccessToken",
            "SudoParam",
            "Token",
        ]  # noqa: E501

        _response_types_map = {
            "200": "List[User]",
            "403": None,
        }

        return self.api_client.call_api(
            "/admin/users",
            "GET",
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get("async_req"),
            _return_http_data_only=_params.get("_return_http_data_only"),  # noqa: E501
            _preload_content=_params.get("_preload_content", True),
            _request_timeout=_params.get("_request_timeout"),
            collection_formats=_collection_formats,
            _request_auth=_params.get("_request_auth"),
        )

    @overload
    async def admin_unadopted_list(
        self,
        page: Annotated[
            Optional[StrictInt],
            Field(description="page number of results to return (1-based)"),
        ] = None,
        limit: Annotated[
            Optional[StrictInt], Field(description="page size of results")
        ] = None,
        pattern: Annotated[
            Optional[StrictStr],
            Field(description="pattern of repositories to search for"),
        ] = None,
        **kwargs
    ) -> List[str]:  # noqa: E501
        ...

    @overload
    def admin_unadopted_list(
        self,
        page: Annotated[
            Optional[StrictInt],
            Field(description="page number of results to return (1-based)"),
        ] = None,
        limit: Annotated[
            Optional[StrictInt], Field(description="page size of results")
        ] = None,
        pattern: Annotated[
            Optional[StrictStr],
            Field(description="pattern of repositories to search for"),
        ] = None,
        async_req: Optional[bool] = True,
        **kwargs
    ) -> List[str]:  # noqa: E501
        ...

    @validate_arguments
    def admin_unadopted_list(
        self,
        page: Annotated[
            Optional[StrictInt],
            Field(description="page number of results to return (1-based)"),
        ] = None,
        limit: Annotated[
            Optional[StrictInt], Field(description="page size of results")
        ] = None,
        pattern: Annotated[
            Optional[StrictStr],
            Field(description="pattern of repositories to search for"),
        ] = None,
        async_req: Optional[bool] = None,
        **kwargs
    ) -> Union[List[str], Awaitable[List[str]]]:  # noqa: E501
        """List unadopted repositories  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.admin_unadopted_list(page, limit, pattern, async_req=True)
        >>> result = thread.get()

        :param page: page number of results to return (1-based)
        :type page: int
        :param limit: page size of results
        :type limit: int
        :param pattern: pattern of repositories to search for
        :type pattern: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: List[str]
        """
        kwargs["_return_http_data_only"] = True
        if async_req is not None:
            kwargs["async_req"] = async_req
        return self.admin_unadopted_list_with_http_info(
            page, limit, pattern, **kwargs
        )  # noqa: E501

    @validate_arguments
    def admin_unadopted_list_with_http_info(
        self,
        page: Annotated[
            Optional[StrictInt],
            Field(description="page number of results to return (1-based)"),
        ] = None,
        limit: Annotated[
            Optional[StrictInt], Field(description="page size of results")
        ] = None,
        pattern: Annotated[
            Optional[StrictStr],
            Field(description="pattern of repositories to search for"),
        ] = None,
        **kwargs
    ):  # noqa: E501
        """List unadopted repositories  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.admin_unadopted_list_with_http_info(page, limit, pattern, async_req=True)
        >>> result = thread.get()

        :param page: page number of results to return (1-based)
        :type page: int
        :param limit: page size of results
        :type limit: int
        :param pattern: pattern of repositories to search for
        :type pattern: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(List[str], status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = ["page", "limit", "pattern"]
        _all_params.extend(
            [
                "async_req",
                "_return_http_data_only",
                "_preload_content",
                "_request_timeout",
                "_request_auth",
                "_content_type",
                "_headers",
            ]
        )

        # validate the arguments
        for _key, _val in _params["kwargs"].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method admin_unadopted_list" % _key
                )
            _params[_key] = _val
        del _params["kwargs"]

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        if _params.get("page") is not None:  # noqa: E501
            _query_params.append(("page", _params["page"]))

        if _params.get("limit") is not None:  # noqa: E501
            _query_params.append(("limit", _params["limit"]))

        if _params.get("pattern") is not None:  # noqa: E501
            _query_params.append(("pattern", _params["pattern"]))

        # process the header parameters
        _header_params = dict(_params.get("_headers", {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json"]
        )  # noqa: E501

        # authentication setting
        _auth_settings = [
            "TOTPHeader",
            "AuthorizationHeaderToken",
            "SudoHeader",
            "BasicAuth",
            "AccessToken",
            "SudoParam",
            "Token",
        ]  # noqa: E501

        _response_types_map = {
            "200": "List[str]",
            "403": None,
        }

        return self.api_client.call_api(
            "/admin/unadopted",
            "GET",
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get("async_req"),
            _return_http_data_only=_params.get("_return_http_data_only"),  # noqa: E501
            _preload_content=_params.get("_preload_content", True),
            _request_timeout=_params.get("_request_timeout"),
            collection_formats=_collection_formats,
            _request_auth=_params.get("_request_auth"),
        )
